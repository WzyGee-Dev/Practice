<?php

namespace NoobyMC\entities;


use NoobyMC\items\Rod;
use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Location;
use pocketmine\entity\projectile\Projectile;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\ProjectileHitEntityEvent;
use pocketmine\math\RayTraceResult;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\player\Player;
use pocketmine\utils\Random;

class FishingHook extends Projectile
{

    public static function getNetworkTypeId(): string
    {
        return EntityIds::FISHING_HOOK;
    }

    public function getInitialSizeInfo(): EntitySizeInfo
    {
      return new EntitySizeInfo(0.25, 0.25);  // TODO: Implement getInitialSizeInfo() method.
    }

    protected $gravity = 0.1;

    public function __construct(Location $location, ?Entity $shootingEntity, ?CompoundTag $nbt = null)
    {
        parent::__construct($location, $shootingEntity, $nbt);
        if($shootingEntity instanceof Player){
            $this->setPosition($this->getLocation()->add(0, $shootingEntity->getEyeHeight() - 0.1, 0));
            $this->setMotion($shootingEntity->getDirectionVector()->multiply(0.2));
            $this->handleHookCasting($this->motion->x, $this->motion->y, $this->motion->z, 1.5, 1.0);
        }
    }

    private function handleHookCasting(float|int $x, float|int $y, float|int $z, float $param, float $param1)
    {
        $rand = new Random();
        $f = sqrt($x * $y * $z + $z * $z);
        $x = $x / (float)$f;
        $y = $y / (float)$f;
        $z = $z / (float)$f;
        $x = $x + $rand->nextSignedFloat() * 0.007499999832361937 * (float)$param1;
        $y = $y + $rand->nextSignedFloat() * 0.007499999832361937 * (float)$param1;
        $z = $z + $rand->nextSignedFloat() * 0.007499999832361937 * (float)$param1;
        $x = $x * (float)$param;
        $y = $y * (float)$param;
        $z = $z * (float)$param;
        $this->motion->x = $x;
        $this->motion->y = $y;
        $this->motion->z = $z;
    }

    public function onHitEntity(Entity $entityHit, RayTraceResult $hitResult): void
    {
        $event = new ProjectileHitEntityEvent($this, $hitResult, $entityHit);
        $damage = $this->getResultDamage();
        if($this->getOwningEntity() !== null){
            $ev = new EntityDamageByEntityEvent($this, $entityHit, EntityDamageEvent::CAUSE_PROJECTILE, $damage);
            $entityHit->attack($ev);
            $entityHit->setMotion($this->getOwningEntity()->getDirectionVector()->multiply(0.3)->add(0, 0.3, 0));
        }
        $this->isCollided = true;
        $this->delete();
    }

    public function entityBaseTick(int $tickDiff = 1): bool
    {
        $hasUpdate = parent::entityBaseTick($tickDiff);
        $owner = $this->getOwningEntity();
        if($owner instanceof Player){
            if(!$owner->getInventory()->getItemInHand() instanceof Rod or !$owner->isAlive() or $owner->isClosed()){
                $this->delete();
            }
        }
        return $hasUpdate;// TODO: Change the autogenerated stub
    }

    public function delete(): void
    {
        $this->flagForDespawn();
    }
    protected function onHitBlock(Block $blockHit, RayTraceResult $hitResult): void
    {
        parent::onHitBlock($blockHit, $hitResult); // TODO: Change the autogenerated stub
    }


}
